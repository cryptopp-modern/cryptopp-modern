# CVE-2024-28285: Fault Injection Vulnerability in ElGamal `SymmetricDecrypt` and Related Hybrid DL Decrypt Paths

**Fixed in:** cryptopp-modern 2026.2.0

This release **remediates the plaintext-release behaviour that enables CVE-2024-28285's fault-oracle**, which specifically affects `SymmetricDecrypt` in `cryptopp/elgamal.h` in Crypto++ 8.9.0. It also hardens the shared `DL_DecryptorBase<T>::Decrypt()` code path used by ECIES and DLIES in cryptopp-modern.

---

## What Was Wrong?

CVE-2024-28285 is a **fault-injection** weakness affecting **ElGamal hybrid decryption** in Crypto++ 8.9.0 (`SymmetricDecrypt`), with **DLIES** and **ECIES** relevant where they share the same hybrid decryption pattern / call path in `DL_DecryptorBase<T>::Decrypt()`.

### Attack model

If an attacker can induce computational faults during decryption (for example, by causing bit flips in memory or transient execution faults on a shared host), then repeated decryptions can yield **faulted plaintext outputs**. Collecting enough of these "garbage" outputs can enable recovery of the private key under known fault-analysis techniques.

Faults may manifest in multiple places during the decrypt flow, including (but not limited to):

- corruption of secret key material before use,
- faults in group operations / exponentiation during key agreement,
- faults in the derived shared secret and subsequent symmetric decrypt.

### Vulnerable behaviour

The original implementation could **write plaintext into the caller's output buffer before the operation was fully validated as successful**. In a fault scenario, this meant a caller could receive faulted plaintext bytes that should never have been released.

### Root cause (practical)

The decrypt path did not enforce a strict *no-write-on-failure* rule. Under fault conditions, partial or incorrect outputs could escape to the caller.

---

## Why This Fix Is More Complete Than the openSUSE Patch

The openSUSE patch adds redundancy to detect certain faults, but it still has important limitations in both **buffer safety** and **fault coverage**.

| Issue | openSUSE Patch | cryptopp-modern Fix |
|-------|----------------|---------------------|
| **Write timing** | Performs the symmetric decrypt into the caller's `plaintext` buffer *before* completing fault checks | Decrypts into temporary storage and only copies to the caller on confirmed success |
| **What gets compared** | Recomputes agreement with the *same* exponent and compares the two results | Uses **blinded verification** so the second computation is mathematically equivalent but (where the implementation doesn't collapse the exponent internally) follows a different computational path |
| **Persistent/deterministic faults** | If a fault is "stuck" or deterministic in the relevant computation, two identical computations can produce the same wrong result (and the check may pass) | Blinding is intended to change intermediate states to improve detection of some deterministic/persistent fault classes (subject to implementation details such as scalar reduction) |
| **Caller buffer on failure** | Caller buffer may already contain faulted/partial plaintext even if the function ultimately returns failure | Caller buffer remains untouched on all failure paths |
| **Enforcement point** | Fault check occurs after decrypt has potentially written output | Fault checks are performed **before releasing plaintext** to the caller |

**Concrete ordering difference:** In the openSUSE patch, the symmetric decrypt is performed first, and only after that does it recompute agreement and compare results — meaning the plaintext buffer can already be populated even when the function returns failure. The cryptopp-modern fix changes the invariant: **no plaintext is released unless the operation is validated as successful.**

**Key insight:** "Compute the same thing twice" redundancy can miss **persistent/deterministic faults** because both computations can fail in the same way. Blinded verification aims to make the verification computation materially different at the execution level while remaining mathematically equivalent in the group, improving the likelihood of detecting faults that simple identical recomputation can't reliably catch (especially when the implementation does not reduce the blinded exponent back to the original exponent internally).

---

## Security Guarantee

> **Hybrid DL decrypt never writes plaintext to caller memory unless `DecodingResult` indicates valid decoding (and any integrity/MAC checks pass where applicable). Faults in key-agreement computations are detected via redundant blinded verification before any plaintext is released.**

---

## How the Fix Enforces the Guarantee

### 1) Ciphertext length validation

- Validate ciphertext length before any processing
- Reject ciphertexts too short to contain a valid group element
- Prevents out-of-bounds reads and `size_t` underflow

### 2) Exponent blinding verification

- After computing `z = ephemeralPub^x`, compute a blinded verification `z2 = ephemeralPub^(x + k*order)` where `k` is random
- Mathematically `z == z2` for valid computations because `ephemeralPub^order = identity`
- **Precondition:** This identity relies on public element validation and correct subgroup membership / order assumptions, enforced by element decoding/validation and by the key-agreement routine's public-key validation
- If `z != z2`, a computational fault is detected; reject decryption immediately
- This is intended to detect transient faults and some classes of persistent/deterministic faults that would otherwise leak key material

> **Implementation note:** In environments where the underlying exponentiation routine reduces scalars modulo the group order, the "different execution path" benefit of blinding may be reduced. The *no-write-on-failure* guarantee still holds regardless.

### 3) No-write-on-failure via temporary buffer

- Decrypt into a temporary `SecByteBlock`
- Copy to the caller's buffer only on success (`DecodingResult.isValidCoding == true`)
- On any failure path, return `DecodingResult()` with the caller buffer unchanged

### 4) Defence-in-depth in `ElGamalBase::SymmetricDecrypt()`

- Validate ciphertext length before computation
- Validate embedded plaintext length field before writing
- Decode into temporary storage and copy only on success

---

## Compatibility and operational impact

- **RNG parameter now used:** `DL_DecryptorBase::Decrypt(RandomNumberGenerator& rng, ...)` now uses the RNG parameter for blinding verification. Previously this parameter was ignored (`CRYPTOPP_UNUSED(rng);`). All existing Crypto++ code already passes a real RNG (e.g., `GlobalRNG()`), so this change is backward compatible with existing usage patterns.
- **Performance:** Decryption performs one additional group exponentiation (verification) before releasing plaintext.

---

## What Is Explicitly Out of Scope?

This mitigation **does not** address:

- **Long-term key corruption:** persistent corruption of stored private key material
- **Non-fault side channels:** timing, power, or electromagnetic analysis unrelated to computational faults
- **ElGamal integrity:** ElGamal padding does not provide authentication; tampered ciphertexts may decrypt to garbage without detection
- **Key generation faults:** faults occurring during key generation
- **Faults during the comparison itself:** if the `z == z2` comparison is faulted, the check could be bypassed
- **Control-flow faulting:** faults that cause execution to skip checks entirely are out of scope

**Recommended usage:** Where possible, prefer authenticated encryption (KEM+AEAD constructions) so tampering is detected cryptographically rather than relying solely on fault detection.

---

## Files Changed

| File | Change |
|------|--------|
| `include/cryptopp/pubkey.h` | Harden `DL_DecryptorBase::Decrypt()` with length validation, blinding verification, and temp buffer |
| `include/cryptopp/elgamal.h` | Harden `ElGamalBase::SymmetricDecrypt()` (validate before write) |
| `src/test/validat_cve_2024_28285.cpp` | New security validation tests with blinding stress tests |
| `Security.md` | CVE entry and security guarantee |
| `History.txt` | Changelog entry |

---

## Test Coverage

All existing test vectors pass:

- `cryptest.exe v 17` — ElGamal validation
- `cryptest.exe v 62` — DLIES validation
- `cryptest.exe v 23` — ECIES/ECP validation

New security tests (`cryptest.exe v 95`):

- ElGamal normal encryption/decryption
- ElGamal no-write-on-failure (invalid length)
- ElGamal no-write-on-failure (corrupted ephemeral key)
- ECIES normal encryption/decryption
- ECIES no-write-on-failure (invalid length)
- ECIES no-write-on-failure (corrupted MAC)
- Blinding math validation (100+ iterations)
- Group operations validation (100+ iterations)
- Stress test (1000+ iterations with random blinding factors)

---

## References

- CVE-2024-28285 : https://nvd.nist.gov/vuln/detail/CVE-2024-28285
- [Crypto++ Issue #1262 (original Rowhammer report)](https://github.com/weidai11/cryptopp/issues/1262)
- [cryptopp-modern Issue #12](https://github.com/cryptopp-modern/cryptopp-modern/issues/12)
- [openSUSE patch](https://build.opensuse.org/projects/home%3Adgarcia%3Alibxml2%3Aalpha/packages/libcryptopp/files/libcryptopp-CVE-2024-28285.patch)
- [Ubuntu CVE tracker](https://ubuntu.com/security/CVE-2024-28285)
